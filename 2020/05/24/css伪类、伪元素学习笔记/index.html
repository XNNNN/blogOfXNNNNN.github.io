<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="xnnnnn">
  <meta name="description" content="X_NNNNN的博客">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  
  
  <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
  <link rel="dns-prefetch" href="https://api.github.com">
  <link rel="dns-prefetch" href="https://avatars3.githubusercontent.com">
  
  <link rel="stylesheet" type="text/css" href="/./style/main.css">
	<link rel="shortcut icon" href="/./img/aside/20gh00.jpg" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>css伪类、伪元素学习笔记</title>
  
  
</head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/">X_NNNNN</a>
  <a class="face-img" href="/">
    <img src="/./img/aside/20gh00.jpg">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    css伪类、伪元素学习笔记
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2020-05-24T15:11:48.000Z" itemprop="datePublished">2020-05-24</time>
      </li>
      <li>
        
    更新 <time datetime="2020-06-12T03:33:45.624Z" itemprop="dateUpdated">2020-06-12</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <h1 id="什么是伪类"><a href="#什么是伪类" class="headerlink" title="什么是伪类"></a>什么是伪类</h1><p>是一种CSS的内置类，名字叫伪类(不要纠结为什么叫伪类，就跟人的名字一样)，她被赋予了一些特性和功能：可以不用选择器就能拿来用。<br>伪类则是像真正的类一样发挥这类的作用，没有数量上的限制，只要不互相排斥也能用到相同的元素上。<br>官方解释是：伪类对元素的名称、属性、内容以外的特征进行分类。伪类可以是动态的，当用户与元素进行交互时元素可能触发伪类。</p>
<h1 id="什么是伪元素"><a href="#什么是伪元素" class="headerlink" title="什么是伪元素"></a>什么是伪元素</h1><p>可以想象成一种元素，一种不能直接用css其他写法表示出来的。比如你想用css获取一篇文字的第一个字母，或者第一行，这个时候光用普通的选择器很难实现，这时候就是伪元素显身手的时候了。<strong>伪元素是选中某个元素符合逻辑却实际上不存在的部分</strong><br>到目前为止，伪元素在一个选择器里只能出现一次，并且只能出现在末尾</p>
<h1 id="原文说明"><a href="#原文说明" class="headerlink" title="原文说明"></a>原文说明</h1><ul>
<li><p>Pseudo-elements create abstractions about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. CSS pseudo-elements allow style sheet designers to refer to this otherwise inaccessible information. Pseudo-elements may also provide style sheet designers a way to assign style to content that does not exist in the source document (e.g., the :before and :after pseudo-elements give access to generated content).</p>
</li>
<li><p>Pseudo-classes classify elements on characteristics other than their name, attributes or content; in principle characteristics that cannot be deduced from the document tree. Pseudo-classes may be dynamic, in the sense that an element may acquire or lose a pseudo-class while a user interacts with the document. The exceptions are ‘:first-child’, which can be deduced from the document tree, and ‘:lang()’, which can be deduced from the document tree in some cases</p>
<h1 id="写法上的区别"><a href="#写法上的区别" class="headerlink" title="写法上的区别"></a>写法上的区别</h1><p>CSS3为了区分这两者。在语法上作出了区别：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-child</span>&#123;</span><br><span class="line">    //一个冒号是伪类</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::first-line</span>&#123;</span><br><span class="line">    //两个冒号是伪元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="元素优先级"><a href="#元素优先级" class="headerlink" title="元素优先级"></a>元素优先级</h1><p><strong>分开各自作为真正的类和元素计算。</strong></p>
<h1 id="标准伪类索引-不包括实验中的API"><a href="#标准伪类索引-不包括实验中的API" class="headerlink" title="标准伪类索引(不包括实验中的API)"></a>标准伪类索引(不包括实验中的API)</h1><ul>
<li><p>:active:<br>匹配配用户激活的元素。他代表按下到松开之间的时间。一般用于a标签访问过的颜色。</p>
</li>
<li><p>:last-of-type<br>表示在他父元素的子元素列表中，最后一个元素。</p>
</li>
<li><p>:left<br>这个需要和@page配套使用，设置打印文档左侧的css样式。没用过不多说</p>
</li>
<li><p>:link<br>用来选中元素中的链接，她会选中所有尚未访问的链接，包括那些已经被其他伪类选中的(比如： hover、active、visited)。所以link伪类应该放到其他伪类前面。并遵循：<strong>LVHA</strong>、即link-&gt;visited-&gt;hover-&gt;active</p>
</li>
<li><p>:checked<br>标识任何处于选中状态的radio。</p>
</li>
<li><p>:not<br>用来匹配不符合一组选择器的元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 选择所有不是P的元素</span><br><span class="line"><span class="selector-pseudo">:not(p)</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>:default<br>表示一组相关元素中的默认表单元素。</p>
</li>
<li><p>:nth-child(an+b)<br>这个伪类首先找到所有当前元素的兄弟元素，然后按照位置选后顺序从一开始，选择结果是括号中的表达式。</p>
<ul>
<li>0n+3 or 3 都匹配第三个元素</li>
<li>1n or n 匹配每个元素</li>
<li>2n 匹配偶数2 4 6 8的元素，可用even代替。</li>
<li>2n+1 匹配奇数1 3 5 7的元素，可用odd代替。<br>注意：a、b都必须为整数，an必须写在b的前面。</li>
</ul>
</li>
<li><p>:nth-last-child()<br>从兄弟节点中从后往前匹配处于某些位置的元素,这个伪类和 :nth-child 基本一致, 但它是从结尾计数, 而不是从开始计数.</p>
</li>
<li><p>:defined<br>表示任何已定义的元素。这包括任何浏览器内置的标准元素以及已成功定义的自定义元素.</p>
</li>
<li><p>:disabled<br>表示任何被禁用的元素。如果一个元素不能被激活（如选择、点击或接受文本输入）或获取焦点，则该元素处于被禁用状态。</p>
</li>
<li><p>nth-last-of-type(an+b)<br>匹配那些在它之后有 an+b-1 个相同类型兄弟节点的元素，其中 n 为正值或零值。它基本上和 :nth-of-type 一样，只是它从结尾处反序计数，而不是从开头处。</p>
</li>
<li><p>:empty<br>代表没有子元素的元素。子元素只可以是元素节点或文本（包括空格）</p>
</li>
<li><p>:nth-of-type<br>这个 CSS 伪类是针对具有一组兄弟节点的标签, 用 n 来筛选出在一组兄弟节点的位置。</p>
</li>
<li><p>enabled<br>表示任何被启用的（enabled）元素。如果一个元素能够被激活（如选择、点击或接受文本输入），或者能够获取焦点，则该元素是启用的。</p>
</li>
<li><p>:only-child<br>匹配没有任何兄弟元素的元素.</p>
</li>
<li><p>:first<br>打印文档的时候，第一页的样式。打印的属性不多说。</p>
</li>
<li><p>:only-of-type<br>代表了任意一个元素，这个元素没有其他相同类型的兄弟元素。</p>
</li>
<li><p>first-child<br>表示在一组兄弟元素中的第一个元素</p>
</li>
<li><p>:first-of-type<br>表示一组兄弟元素中其类型的第一个元素，比如父元素内混合着p和div，这个就能拿到第一个p或者第一个div</p>
</li>
<li><p>:out-of-range<br>表示一个input元素，其当前值属于min和max之外的时候。</p>
</li>
<li><p>:fullscreen<br>应用于当前处于全屏显示模式的元素，他能选择顶级元素，还包括所有已经显示的栈内元素。</p>
</li>
<li><p>:focus<br>表示获得焦点的元素。用户点击或者触摸或者键盘tab选择到他时会被触发。</p>
</li>
<li><p>:read-only<br>表示不可以被用户编辑的元素。</p>
</li>
<li><p>:read-write<br>表示可以编辑的元素。</p>
</li>
</ul>

      </div>
        <div class="support-author">
          <p>感谢您的阅读。 🙏
          <!-- <a href="https://888.com/index.html" target="_blank">关于转载请看这里</a> -->
            <!--<a class="btn-pay"  href="#pay-modal">¥ 打赏支持</a>-->
          </p>
        </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script type="text/javascript">
  const gitalk = new Gitalk({
    clientID: '7bd7d05b167b51a6e7e3',
    clientSecret: '67c9eeb18ea1a16443ed9f0eb8d159dc8f9f5694',
    repo: 'https://github.com/XNNNN/blogOfX_NNNNN.github.io',
    owner: 'X_NNNNN',
    admin: ['X_NNNNN'],
    id: location.pathname,      // Ensure uniqueness and length less than 50
    distractionFreeMode: false
  })

  gitalk.render('comments');
</script>


        </div>
      </div>
    </div>
   
</main>
<div class="footer">
  <div class="info">
    <p>
    <a href="https://hexo.io"> Hexo </a> 强力驱动 |
      <a href="https://github.com/Youthink/hexo-themes-yearn"> Yearn </a>
      主题
    </p>
    <p>&copy; </p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



<script>//console
  var consoleConfig = '\n欢迎访问 (づ｡◕‿‿◕｡)づ！\n'.split(',');
  var canConsole = true;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":70,"vOffset":30},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
