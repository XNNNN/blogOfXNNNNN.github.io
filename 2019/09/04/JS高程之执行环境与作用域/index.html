<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="John Doe"><meta name="renderer" content="webkit"><meta name="copyright" content="John Doe"><meta name="keywords" content="Hexo"><meta name="description" content="null"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>JS高程之执行环境与作用域 · X丶NNNNN</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/未标题-1.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">X丶NNNNN</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/63513874_p0.jpg);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">Welcome to my Blog!</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">JS高程之执行环境与作用域</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2019-09-04</span></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>先开个坑坑，明天来码字。 （部分代码来自阮一峰的es6入门）</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><h3 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h3><p>执行环境决定了变量或者函数是否有权利访问其他数据和行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中的定义的变量都核函数都保存在这个对象中。我们不能直接访问这个对象，但解析器在这个处理数据时会在后台使用她</p>
<ul>
<li><p>全局环境：是最外围的一个执行环境。在Web浏览器中全局执行环境被认为是window对象。</p>
</li>
<li><p>执行环境：每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。<br>当代码在一个执行环中执行时，会创建变量对象的一个<strong>作用域链</strong>。</p>
</li>
<li><p>作用域链的作用：保证对执行环境有权访问的所有变量核函数的<strong>有序访问</strong>。</p>
</li>
<li><p>作用域的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数则将其活动对象作为变量对象。活动对象最开始时是包含一个变量（arguments对象），作用域链中的下一个变量对象来自包含（外部）环境，而在下一个变量对象则来自下一个包含环境。一直延续到全局执行环境。全局执行对象始终都是作用域链中的最后一个对象。</p>
</li>
<li><p>我的白话理解就是，你想知道这个人姓什么。可以直接问本人，他知道告诉你了就是相当于在执行环境。他没告诉你，你还可以问他爸爸姓什么（全局环境），还可以问他爷爷姓什么。同理这样一层层往上查。都不知道的话他可能就会说”不知道”，这时候就是我们说的变量未定义就访问了所以是undefined。</p>
<h3 id="延长作用域链接"><a href="#延长作用域链接" class="headerlink" title="延长作用域链接"></a>延长作用域链接</h3><p>虽然执行环境的类型总共就两种 —— 全局和局部。但是我们还有其他办法来延长作用域链。</p>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fun()</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fun() have a error'</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里的err就是临时增加的一个变量对象，改变量对象会在代码执行后被移除。</p>
<h4 id="with-（不建议使用）"><a href="#with-（不建议使用）" class="headerlink" title="with （不建议使用）"></a>with （不建议使用）</h4><p>不推荐使用with，在ECMAScript 5 严格模式中该标签已被禁止。推荐的代替方案是声明一个临时变量来承载你所需要的属性。<br><strong>弊端：</strong></p>
<ul>
<li>with 语句在查找变量是，都是先在指定的对象中查找，所以本来不是在这个对象的属性变量，查找起来会很慢。</li>
<li>with 语句使得代码不易阅读</li>
<li>with 语句 无法向前兼容<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3>在ES5之前没有块级作用域（自己的执行环境）。es6新增了let和const命令。<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>for 循环的计数器，就很适合使用 let。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// ReferenceError: i is not defined</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="comment">//logic code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><strong>let  不存在变量提升</strong>。var 命令会发生变量提升的现象，即：可以再声明之前使用，值是undefined。这种逻辑有点奇怪。所以 let 改变了语法行为。在let定义之前调用的话会返回一个错误“ReferenceError”（错误的引用）</p>
<h4 id="暂时性死区-TDZ-temporal-dead-zone"><a href="#暂时性死区-TDZ-temporal-dead-zone" class="headerlink" title="暂时性死区 TDZ(temporal dead zone)"></a>暂时性死区 TDZ(temporal dead zone)</h4><p><strong>只要块级作用内有let命令，他所声明的变量就“绑定”这个作用域，不再受外部影响</strong><br>下面这段代码，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自阮一峰 es6</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let 不允许在相同的作用域内声明同一个变量。var 会覆盖上一个变量，这里有本质上的区别。应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b =<span class="number">2</span> </span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line">a() <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> d =<span class="number">2</span> </span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line">c() <span class="comment">// Identifier 'd' has already been declared</span></span><br></pre></td></tr></table></figure>

<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li>const 声明一个只读变量。一旦声明，常量的值就不能改变。</li>
<li>不能改变意味着声明必须初始化赋值。</li>
<li>与 let 一样存在暂时性死区。</li>
<li>不可重复声明，只在块级作用域内有效 。</li>
</ul>
<p><strong>本质：</strong>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p>
<ul>
<li>对于简单类型的数据，值就是保存在变量指向的那个内存地址，因此等同常量。</li>
<li>对于复合类型的数据，变量指向的内存地址，保存的只是一个指向实际数据的指针。const 只能保证这个指针是股东的，至于他只想的数据结构是不是可变的，就完全不能控制了。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span></span><br><span class="line">foo.prop <span class="comment">// 123</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><!-- lincense--><div class="post-paginator"><a class="nextSlogan" href="/2019/09/02/JS高程之基本类型和引用类型/" title="JS高程之基本类型和引用类型"><span>NextPost ></span><br><span class="nextTitle">JS高程之基本类型和引用类型</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  id: 'JS高程之执行环境与作用域',
  owner: 'X_NNNNN',
  repo: 'blogOfX_NNNNN.github.io',
  oauth: {
    client_id: 'a61c2a7fac0543d1cc52',
    client_secret: 'af6b1d3e0d8289a66e9c6d60b93214b3fa8fd663',
  },
})
gitment.render('container')</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?" + 'ab2813deffd5aaf5cab295d48b65151e';
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#执行环境及作用域"><span class="toc-number">1.</span> <span class="toc-text">执行环境及作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#执行环境（execution-context）"><span class="toc-number">1.1.</span> <span class="toc-text">执行环境（execution context）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#延长作用域链接"><span class="toc-number">1.2.</span> <span class="toc-text">延长作用域链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch"><span class="toc-number">1.2.1.</span> <span class="toc-text">try-catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with-（不建议使用）"><span class="toc-number">1.2.2.</span> <span class="toc-text">with （不建议使用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#块级作用域"><span class="toc-number">1.3.</span> <span class="toc-text">块级作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#let"><span class="toc-number">1.3.1.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#暂时性死区-TDZ-temporal-dead-zone"><span class="toc-number">1.3.2.</span> <span class="toc-text">暂时性死区 TDZ(temporal dead zone)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不允许重复声明"><span class="toc-number">1.3.3.</span> <span class="toc-text">不允许重复声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">1.3.4.</span> <span class="toc-text">const</span></a></li></ol></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":70,"vOffset":30},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>